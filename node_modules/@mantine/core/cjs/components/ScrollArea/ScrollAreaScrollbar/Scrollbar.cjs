'use client';
'use strict';

var React = require('react');
var hooks = require('@mantine/hooks');
var ScrollArea_context = require('../ScrollArea.context.cjs');
var useResizeObserver = require('../use-resize-observer.cjs');
var composeEventHandlers = require('../utils/compose-event-handlers.cjs');
var Scrollbar_context = require('./Scrollbar.context.cjs');

function _interopDefault (e) { return e && e.__esModule ? e : { default: e }; }

var React__default = /*#__PURE__*/_interopDefault(React);

const Scrollbar = React.forwardRef((props, forwardedRef) => {
  const {
    sizes,
    hasThumb,
    onThumbChange,
    onThumbPointerUp,
    onThumbPointerDown,
    onThumbPositionChange,
    onDragScroll,
    onWheelScroll,
    onResize,
    ...scrollbarProps
  } = props;
  const context = ScrollArea_context.useScrollAreaContext();
  const [scrollbar, setScrollbar] = React__default.default.useState(null);
  const composeRefs = hooks.useMergedRef(forwardedRef, (node) => setScrollbar(node));
  const rectRef = React__default.default.useRef(null);
  const prevWebkitUserSelectRef = React__default.default.useRef("");
  const { viewport } = context;
  const maxScrollPos = sizes.content - sizes.viewport;
  const handleWheelScroll = hooks.useCallbackRef(onWheelScroll);
  const handleThumbPositionChange = hooks.useCallbackRef(onThumbPositionChange);
  const handleResize = hooks.useDebounceCallback(onResize, 10);
  const handleDragScroll = (event) => {
    if (rectRef.current) {
      const x = event.clientX - rectRef.current.left;
      const y = event.clientY - rectRef.current.top;
      onDragScroll({ x, y });
    }
  };
  React.useEffect(() => {
    const handleWheel = (event) => {
      const element = event.target;
      const isScrollbarWheel = scrollbar?.contains(element);
      if (isScrollbarWheel)
        handleWheelScroll(event, maxScrollPos);
    };
    document.addEventListener("wheel", handleWheel, { passive: false });
    return () => document.removeEventListener("wheel", handleWheel, { passive: false });
  }, [viewport, scrollbar, maxScrollPos, handleWheelScroll]);
  React.useEffect(handleThumbPositionChange, [sizes, handleThumbPositionChange]);
  useResizeObserver.useResizeObserver(scrollbar, handleResize);
  useResizeObserver.useResizeObserver(context.content, handleResize);
  return /* @__PURE__ */ React__default.default.createElement(
    Scrollbar_context.ScrollbarProvider,
    {
      value: {
        scrollbar,
        hasThumb,
        onThumbChange: hooks.useCallbackRef(onThumbChange),
        onThumbPointerUp: hooks.useCallbackRef(onThumbPointerUp),
        onThumbPositionChange: handleThumbPositionChange,
        onThumbPointerDown: hooks.useCallbackRef(onThumbPointerDown)
      }
    },
    /* @__PURE__ */ React__default.default.createElement(
      "div",
      {
        ...scrollbarProps,
        ref: composeRefs,
        style: { position: "absolute", ...scrollbarProps.style },
        onPointerDown: composeEventHandlers.composeEventHandlers(props.onPointerDown, (event) => {
          const mainPointer = 0;
          if (event.button === mainPointer) {
            const element = event.target;
            element.setPointerCapture(event.pointerId);
            rectRef.current = scrollbar.getBoundingClientRect();
            prevWebkitUserSelectRef.current = document.body.style.webkitUserSelect;
            document.body.style.webkitUserSelect = "none";
            handleDragScroll(event);
          }
        }),
        onPointerMove: composeEventHandlers.composeEventHandlers(props.onPointerMove, handleDragScroll),
        onPointerUp: composeEventHandlers.composeEventHandlers(props.onPointerUp, (event) => {
          const element = event.target;
          if (element.hasPointerCapture(event.pointerId)) {
            element.releasePointerCapture(event.pointerId);
          }
          document.body.style.webkitUserSelect = prevWebkitUserSelectRef.current;
          rectRef.current = null;
        })
      }
    )
  );
});

exports.Scrollbar = Scrollbar;
//# sourceMappingURL=Scrollbar.cjs.map
