'use client';
'use strict';

var React = require('react');
var hooks = require('@mantine/hooks');
var ScrollArea_context = require('../ScrollArea.context.cjs');
var isScrollingWithinScrollbarBounds = require('../utils/is-scrolling-within-scrollbar-bounds.cjs');
var getThumbSize = require('../utils/get-thumb-size.cjs');
var toInt = require('../utils/to-int.cjs');
var Scrollbar = require('./Scrollbar.cjs');

function _interopDefault (e) { return e && e.__esModule ? e : { default: e }; }

var React__default = /*#__PURE__*/_interopDefault(React);

const ScrollAreaScrollbarY = React.forwardRef(
  (props, forwardedRef) => {
    const { sizes, onSizesChange, style, ...others } = props;
    const context = ScrollArea_context.useScrollAreaContext();
    const [computedStyle, setComputedStyle] = React__default.default.useState();
    const ref = React.useRef(null);
    const composeRefs = hooks.useMergedRef(forwardedRef, ref, context.onScrollbarYChange);
    React.useEffect(() => {
      if (ref.current)
        setComputedStyle(getComputedStyle(ref.current));
    }, [ref]);
    return /* @__PURE__ */ React__default.default.createElement(
      Scrollbar.Scrollbar,
      {
        ...others,
        "data-orientation": "vertical",
        ref: composeRefs,
        sizes,
        style: {
          ["--sa-thumb-height"]: `${getThumbSize.getThumbSize(sizes)}px`,
          ...style
        },
        onThumbPointerDown: (pointerPos) => props.onThumbPointerDown(pointerPos.y),
        onDragScroll: (pointerPos) => props.onDragScroll(pointerPos.y),
        onWheelScroll: (event, maxScrollPos) => {
          if (context.viewport) {
            const scrollPos = context.viewport.scrollTop + event.deltaY;
            props.onWheelScroll(scrollPos);
            if (isScrollingWithinScrollbarBounds.isScrollingWithinScrollbarBounds(scrollPos, maxScrollPos)) {
              event.preventDefault();
            }
          }
        },
        onResize: () => {
          if (ref.current && context.viewport && computedStyle) {
            onSizesChange({
              content: context.viewport.scrollHeight,
              viewport: context.viewport.offsetHeight,
              scrollbar: {
                size: ref.current.clientHeight,
                paddingStart: toInt.toInt(computedStyle.paddingTop),
                paddingEnd: toInt.toInt(computedStyle.paddingBottom)
              }
            });
          }
        }
      }
    );
  }
);

exports.ScrollAreaScrollbarY = ScrollAreaScrollbarY;
//# sourceMappingURL=ScrollbarY.cjs.map
